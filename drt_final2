import os
import sys
import traci
import random
from collections import deque 

if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    sys.exit("SUMO_HOME 환경변수를 설정해주세요.")

class DRTVehicle:
    def __init__(self, vehicle_id):
        self.id = vehicle_id
        self.current_route = []
        self.passengers = []
        self.status = "IDLE"
        self.capacity = 11
        self.current_occupancy = 0
        self.scheduled_stops = []
        self.last_edge = None
        self.active = True
        self.distance_traveled = 0
        self.last_position = None

    def can_accept_passengers(self, num_passengers):
        return self.current_occupancy + num_passengers <= self.capacity

    def update_distance(self, current_position):
        if self.last_position:
            dx = current_position[0] - self.last_position[0]
            dy = current_position[1] - self.last_position[1]
            distance = (dx * dx + dy * dy) ** 0.5
            self.distance_traveled += distance
        self.last_position = current_position

class DRTRequest:
    def __init__(self, request_id, origin, destination, num_passengers):
        self.id = request_id
        self.origin = origin
        self.destination = destination
        self.num_passengers = num_passengers
        self.status = "WAITING"
        self.pickup_time = None
        self.dropoff_time = None
        self.request_time = traci.simulation.getTime()
        self.assigned_vehicle = None
        self.assigned_passengers = []
        self.can_carpool = True

class DRTMetrics:
    def __init__(self):
        self.total_wait_time = 0
        self.total_travel_time = 0
        self.total_requests = 0
        self.rejected_requests = 0
        self.shared_rides = 0
        self.total_direct_distance = 0
        self.total_actual_distance = 0
        self.total_empty_distance = 0
        self.total_vehicle_hours = 0
        self.total_occupied_hours = 0
        self.total_passengers = 0
        self.completed_requests = 0

    def calculate_metrics(self):
        # 지표 계산시 0으로 나누는 것을 방지
        def safe_divide(a, b, default=0):
            return a / b if b > 0 else default

        metrics = {
            "서비스 품질 지표": {
                "평균 대기 시간 (분)": safe_divide(self.total_wait_time, self.completed_requests) / 60,
                "평균 이동 시간 (분)": safe_divide(self.total_travel_time, self.completed_requests) / 60,
                "요청 거절률 (%)": safe_divide(self.rejected_requests * 100, self.total_requests),
                "합승률 (%)": safe_divide(self.shared_rides * 100, self.completed_requests),
                "평균 우회도": safe_divide(self.total_actual_distance, self.total_direct_distance)
            },
            "운영 효율성 지표": {
                "차량 가동률 (%)": safe_divide(self.total_occupied_hours * 100, self.total_vehicle_hours),
                "공차 비율 (%)": safe_divide(self.total_empty_distance * 100, self.total_actual_distance),
                "승객 km당 운행 거리": safe_divide(self.total_actual_distance, self.total_passengers),
                "평균 탑승률": safe_divide(self.total_passengers, self.completed_requests)
            }
        }
        return metrics

class DRTSystem:
    def __init__(self):
        self.vehicles = {}
        self.requests = {}
        self.request_counter = 0
        self.completed_requests = []
        self.rejected_requests = []
        self.waiting_requests = deque()
        self.buron_base = "-1006685487"
        self.metrics = DRTMetrics()
        self.max_waiting_time = 600  # 10분 최대 대기 시간

    def check_vehicle_existence(self, vehicle_id):
        try:
            traci.vehicle.getPosition(vehicle_id)
            return True
        except traci.exceptions.TraCIException:
            return False

    def reset_vehicle(self, vehicle_id):
        try:
            if self.check_vehicle_existence(vehicle_id):
                traci.vehicle.remove(vehicle_id)
            
            traci.vehicle.add(vehicle_id, "route_0", typeID="drt_vehicle")
            traci.vehicle.setStop(vehicle_id, self.buron_base, duration=1)
            traci.vehicle.setColor(vehicle_id, (255, 255, 255))
            vehicle = self.vehicles[vehicle_id]
            vehicle.status = "IDLE"
            vehicle.current_occupancy = 0
            vehicle.scheduled_stops = []
            vehicle.last_edge = self.buron_base
            print(f"차량 {vehicle_id} 재배치됨")
        except traci.exceptions.TraCIException as e:
            print(f"차량 재배치 실패: {e}")

    def add_vehicle(self, vehicle_id):
        try:
            if self.check_vehicle_existence(vehicle_id):
                traci.vehicle.remove(vehicle_id)
            
            traci.vehicle.add(vehicle_id, "route_0", typeID="drt_vehicle")
            traci.vehicle.setStop(vehicle_id, self.buron_base, duration=1)
            traci.vehicle.setColor(vehicle_id, (255, 255, 255))
            vehicle = DRTVehicle(vehicle_id)
            vehicle.last_edge = self.buron_base
            self.vehicles[vehicle_id] = vehicle
            print(f"차량 {vehicle_id} 추가됨 (12인승)")
        except traci.exceptions.TraCIException as e:
            print(f"차량 추가 실패: {e}")

    def add_request(self, origin, destination):
        self.metrics.total_requests += 1
        num_passengers = random.randint(1, 4)
        request_id = f"req_{self.request_counter}"
        self.request_counter += 1
        
        request = DRTRequest(request_id, origin, destination, num_passengers)
        self.requests[request_id] = request
        
        # 직선 거리 계산
        try:
            route = traci.simulation.findRoute(origin, destination)
            self.metrics.total_direct_distance += route.length
        except traci.exceptions.TraCIException:
            pass
        
        self.find_available_vehicle(request_id)
        return request_id

    def find_available_vehicle(self, request_id):
        request = self.requests[request_id]
        available_vehicles = []
        
        for vehicle_id, vehicle in self.vehicles.items():
            if not vehicle.active:
                continue
                
            if vehicle.can_accept_passengers(request.num_passengers):
                try:
                    current_edge = traci.vehicle.getRoadID(vehicle_id)
                    if current_edge == '':
                        current_edge = vehicle.last_edge
                        
                    if vehicle.status in ["IDLE", "RETURN"]:
                        route = traci.simulation.findRoute(current_edge, request.origin)
                        if route.edges:
                            available_vehicles.append((vehicle_id, vehicle, route.length))
                except traci.exceptions.TraCIException:
                    continue
                    
        if not available_vehicles:
            print(f"요청 {request_id}에 대해 가용 차량이 없음 (승객 {request.num_passengers}명)")
            if request not in self.waiting_requests:
                self.waiting_requests.append(request)
            return None
            
        best_vehicle = min(available_vehicles, key=lambda x: x[2])
        vehicle_id = best_vehicle[0]
        
        if self.assign_request_to_vehicle(vehicle_id, request_id):
            print(f"요청 {request_id} (승객 {request.num_passengers}명)이 차량 {vehicle_id}에 할당됨")
            return vehicle_id
            
        return None

    def assign_request_to_vehicle(self, vehicle_id, request_id):
        try:
            vehicle = self.vehicles[vehicle_id]
            request = self.requests[request_id]
            
            current_edge = traci.vehicle.getRoadID(vehicle_id)
            if current_edge == '':
                current_edge = vehicle.last_edge

            if not vehicle.can_accept_passengers(request.num_passengers):
                return False

            # 경로 계획
            pickup_route = traci.simulation.findRoute(current_edge, request.origin)
            if not pickup_route.edges:
                return False
                
            dropoff_route = traci.simulation.findRoute(request.origin, request.destination)
            if not dropoff_route.edges:
                return False

            # 요청 할당
            request.assigned_vehicle = vehicle_id
            request.status = "ASSIGNED"
            
            # 차량 상태 및 승객 업데이트
            vehicle.status = "PICKUP"
            vehicle.passengers.append(request)
            self.metrics.total_passengers += request.num_passengers
            
            # 경로 설정 및 정차 지점 추가
            try:
                # 전체 경로 설정
                complete_route = pickup_route.edges + dropoff_route.edges[1:]
                traci.vehicle.setRoute(vehicle_id, complete_route)
                
                # 픽업 지점에서 정차 설정
                traci.vehicle.setStop(vehicle_id, request.origin, duration=30, flags=1)  # flags=1 은 정차 필수
                
                # 정차 지점 정보 업데이트
                vehicle.scheduled_stops = []
                vehicle.scheduled_stops.append((request.origin, "PICKUP", request_id))
                vehicle.scheduled_stops.append((request.destination, "DROPOFF", request_id))
                
                print(f"Vehicle {vehicle_id} assigned to request {request_id} - Route and stops set")
                return True
            
            except traci.exceptions.TraCIException as e:
                print(f"Failed to set route or stop: {e}")
                return False
            
        except traci.exceptions.TraCIException as e:
            print(f"Error in assign_request_to_vehicle: {e}")
            return False

    def update_vehicles(self):
        current_time = traci.simulation.getTime()
        
        # 대기 중인 요청 처리
        waiting_requests_copy = list(self.waiting_requests)
        self.waiting_requests.clear()
        
        for request in waiting_requests_copy:
            # 최대 대기 시간 초과 시 요청 거절
            if current_time - request.request_time > self.max_waiting_time:
                self.rejected_requests.append(request.id)
                self.metrics.rejected_requests += 1
                print(f"Request {request.id} rejected due to timeout")
                continue
            
            # 아직 처리되지 않은 요청 다시 큐에 추가
            if request.status == "WAITING":
                self.waiting_requests.append(request)

        for vehicle_id, vehicle in self.vehicles.items():
            if not vehicle.active:
                continue
            
            try:
                current_edge = traci.vehicle.getRoadID(vehicle_id)
                current_position = traci.vehicle.getPosition(vehicle_id)
                vehicle.update_distance(current_position)
                
                if current_edge != '':
                    vehicle.last_edge = current_edge

                # 차량이 정류장에 도착했을 때 처리
                if vehicle.scheduled_stops and current_edge == vehicle.scheduled_stops[0][0]:
                    self.process_stop(vehicle_id, current_time)
                
                # 운영 시간 업데이트
                if vehicle.status != "IDLE":
                    self.metrics.total_vehicle_hours += 1
                    if vehicle.current_occupancy > 0:
                        self.metrics.total_occupied_hours += 1
                        self.metrics.total_actual_distance += vehicle.distance_traveled
                    else:
                        self.metrics.total_empty_distance += vehicle.distance_traveled
                    vehicle.distance_traveled = 0

            except traci.exceptions.TraCIException as e:
                print(f"Error updating vehicle {vehicle_id}: {e}")
                continue

    def process_stop(self, vehicle_id, current_time):
        try:
            vehicle = self.vehicles[vehicle_id]
            next_stop, action, request_id = vehicle.scheduled_stops[0]
            request = self.requests[request_id]
            
            if action == "PICKUP":
                vehicle.current_occupancy += request.num_passengers
                request.status = "ONBOARD"
                request.pickup_time = current_time
                self.metrics.total_wait_time += current_time - request.request_time
                
                # 현재 차량에 이미 다른 승객이 있다면 합승으로 간주
                if vehicle.current_occupancy > request.num_passengers:
                    self.metrics.shared_rides += 1
                
                # 다음 정차 지점 설정
                if len(vehicle.scheduled_stops) > 1:
                    next_destination = vehicle.scheduled_stops[1][0]
                    try:
                        traci.vehicle.setStop(vehicle_id, next_destination, duration=10)
                    except traci.exceptions.TraCIException as e:
                        print(f"Failed to set next stop: {e}")
                
            elif action == "DROPOFF":
                vehicle.current_occupancy -= request.num_passengers
                request.status = "COMPLETED"
                request.dropoff_time = current_time
                self.completed_requests.append(request_id)
                self.metrics.completed_requests += 1
                self.metrics.total_travel_time += current_time - request.pickup_time
                
                if request in vehicle.passengers:
                    vehicle.passengers.remove(request)
                
                if not vehicle.passengers:
                    self.return_to_base(vehicle_id)
                elif len(vehicle.scheduled_stops) > 1:
                    next_destination = vehicle.scheduled_stops[1][0]
                    try:
                        traci.vehicle.setStop(vehicle_id, next_destination, duration=10)
                    except traci.exceptions.TraCIException as e:
                        print(f"Failed to set next stop: {e}")
            
            vehicle.scheduled_stops.pop(0)
            
        except Exception as e:
            print(f"Error in process_stop: {e}")
            if len(vehicle.scheduled_stops) > 0:
                vehicle.scheduled_stops.pop(0)
    def return_to_base(self, vehicle_id):
        try:
            vehicle = self.vehicles[vehicle_id]
            current_edge = traci.vehicle.getRoadID(vehicle_id)
            return_route = traci.simulation.findRoute(current_edge, self.buron_base)
            
            if return_route.edges:
                traci.vehicle.setRoute(vehicle_id, return_route.edges)
                vehicle.status = "RETURN"
                traci.vehicle.setColor(vehicle_id, (255, 255, 0))
            else:
                self.reset_vehicle(vehicle_id)
        except traci.exceptions.TraCIException:
            self.reset_vehicle(vehicle_id)
    
    def get_statistics(self):
        stats = {
            "총 요청 수": self.request_counter,
            "완료된 요청 수": len(self.completed_requests),
            "거절된 요청 수": len(self.rejected_requests),
            "대기 중인 요청 수": len(self.waiting_requests),
        }
        return stats

    def get_detailed_statistics(self):
        stats = self.get_statistics()
        metrics = self.metrics.calculate_metrics()
        return {
            "기본 통계": stats,
            "효과성 분석": metrics
        }

def generate_passenger_request():
    # 출발지와 목적지 정의
    origins = ["-1006685487", "-1013458887"]  # 부론면, 흥원면
    destinations = ["-1010175240", "-1060515905", "-1021870413"]  # 문막읍, 소초면, 호저면
    return random.choice(origins), random.choice(destinations)

def run_simulation():
    sumo_binary = "sumo-gui"
    sumo_cmd = [sumo_binary, "-c", "config/wonju.sumocfg"]

    try:
        traci.start(sumo_cmd)
        print("시뮬레이션 시작")

        drt_system = DRTSystem()
        
        # 차량 수 증가
        for i in range(4):  # 2대에서 4대로 증가
            drt_system.add_vehicle(f"drt_{i}")

        step = 0
        next_request_time = random.randint(100, 300)

        while step < 3600:
            traci.simulationStep()
            
            if step >= next_request_time:
                print(f"\n시뮬레이션 시간: {step}초")
                origin, destination = generate_passenger_request()
                request_id = drt_system.add_request(origin, destination)
                next_request_time = step + random.randint(100, 300)

            drt_system.update_vehicles()
            step += 1

        print("\n=== 시뮬레이션 결과 ===")
        detailed_stats = drt_system.get_detailed_statistics()
        
        for category, values in detailed_stats.items():
            print(f"\n{category}:")
            if isinstance(values, dict):
                for key, value in values.items():
                    if isinstance(value, dict):
                        print(f"  {key}:")
                        for subkey, subvalue in value.items():
                            if isinstance(subvalue, float):
                                print(f"    {subkey}: {subvalue:.2f}")
                            else:
                                print(f"    {subkey}: {subvalue}")
                    else:
                        if isinstance(value, float):
                            print(f"  {key}: {value:.2f}")
                        else:
                            print(f"  {key}: {value}")

        traci.close()
        print("\n시뮬레이션 완료")

    except Exception as e:
        print(f"오류 발생: {e}")
        if 'traci' in sys.modules:
            traci.close()

if __name__ == "__main__":
    run_simulation()
